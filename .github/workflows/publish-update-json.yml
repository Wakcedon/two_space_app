name: Publish update.json on release

on:
  release:
    types: [published]

permissions:
  contents: write

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      # No workspace checkout - we use the GitHub API and a temporary clone for gh-pages

      - name: Fetch release via GitHub API
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          RELEASE_ID=${{ github.event.release.id }}
          OWNER=${{ github.repository_owner }}
          REPO=${{ github.event.repository.name }}
          echo "Fetching release ${RELEASE_ID} for ${OWNER}/${REPO}"
          curl -s -H "Authorization: Bearer ${GITHUB_TOKEN}" "https://api.github.com/repos/${OWNER}/${REPO}/releases/${RELEASE_ID}" -o release.json
          echo "Saved release.json"

      - name: Create update.json from fetched release
        run: |
          mkdir -p out
          python - <<'PY'
          import json, os
          with open('release.json', 'r', encoding='utf-8') as f:
            release = json.load(f)
          tag = release.get('tag_name') or release.get('name') or ''
          version = tag.lstrip('v')
          notes = release.get('body') or ''
          asset_url = ''
          assets = release.get('assets') or []
          for asset in assets:
            if asset.get('browser_download_url'):
              asset_url = asset.get('browser_download_url')
              break
          data = {
            'version': version,
            'update_url': asset_url,
            'notes': notes
          }
          out_path = os.path.join('out', 'update.json')
          with open(out_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
          print('Wrote', out_path)
          print(json.dumps(data, ensure_ascii=False))
          PY

      - name: Publish update.json via GitHub Contents API
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OWNER: ${{ github.repository_owner }}
          REPO: ${{ github.event.repository.name }}
          RELEASE_TAG: ${{ github.event.release.tag_name }}
        run: |
          set -e
          # Use the GitHub Contents API to create/update update.json on the gh-pages branch.
          # This avoids any git checkout/working-tree conflicts in the Actions workspace.
          python - <<'PY'
          import base64, json, os, sys, urllib.request, urllib.error

          GITHUB_TOKEN = os.environ['GITHUB_TOKEN']
          OWNER = os.environ['OWNER']
          REPO = os.environ['REPO']
          BRANCH = 'gh-pages'
          PATH = 'update.json'

          with open('out/update.json', 'rb') as f:
            content_bytes = f.read()
          content_b64 = base64.b64encode(content_bytes).decode('ascii')

          api_base = f'https://api.github.com/repos/{OWNER}/{REPO}'
          headers = {
            'Authorization': f'Bearer {GITHUB_TOKEN}',
            'User-Agent': 'github-actions-publish-update-json',
            'Accept': 'application/vnd.github.v3+json'
          }

          def api_get(url):
            req = urllib.request.Request(url, headers=headers, method='GET')
            try:
              with urllib.request.urlopen(req) as resp:
                return resp.status, json.load(resp)
            except urllib.error.HTTPError as e:
              body = e.read().decode()
              try:
                return e.code, json.loads(body) if body else {}
              except Exception:
                return e.code, {'message': body}

          # Get repo info (to find default branch)
          status, repo_info = api_get(api_base)
          if status != 200:
            print('Failed to fetch repo info', status, repo_info)
            sys.exit(1)
          default_branch = repo_info.get('default_branch')

          # Ensure gh-pages branch exists; if not, create it from default_branch
          status, _ = api_get(f'{api_base}/branches/{BRANCH}')
          if status != 200:
            print(f'Branch {BRANCH} not found â€” creating from {default_branch}')
            status, ref_info = api_get(f'{api_base}/git/ref/heads/{default_branch}')
            if status != 200:
              print('Failed to get default branch ref', status, ref_info)
              sys.exit(1)
            sha = ref_info['object']['sha']
            data = json.dumps({'ref': f'refs/heads/{BRANCH}', 'sha': sha}).encode()
            req = urllib.request.Request(f'{api_base}/git/refs', data=data, headers=headers, method='POST')
            try:
              with urllib.request.urlopen(req) as resp:
                print('Created branch', resp.status)
            except urllib.error.HTTPError as e:
              print('Failed to create branch', e.code, e.read().decode())
              sys.exit(1)

          # Check if file exists to get its sha (required for updates)
          status, file_info = api_get(f'{api_base}/contents/{PATH}?ref={BRANCH}')
          existing_sha = file_info.get('sha') if status == 200 else None

          payload = {
            'message': f'chore(publish): update {PATH} for {os.environ.get("RELEASE_TAG")}',
            'content': content_b64,
            'branch': BRANCH
          }
          if existing_sha:
            payload['sha'] = existing_sha

          data = json.dumps(payload).encode()
          req = urllib.request.Request(f'{api_base}/contents/{PATH}', data=data, headers=headers, method='PUT')
          try:
            with urllib.request.urlopen(req) as resp:
              res = json.load(resp)
              print('Published:', res.get('content', {}).get('path'))
          except urllib.error.HTTPError as e:
            print('Failed to publish file', e.code, e.read().decode())
            sys.exit(1)
          PY
